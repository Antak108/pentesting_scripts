import ssl
import socket
import requests
import dns.resolver
import from bs4 import BeautifulSoup

# Replace 'HOSTNAME' with the hostname of the website you want to check
hostname = 'google.com'

# Establish a secure connection to the website
context = ssl.create_default_context()
conn = context.wrap_socket(socket.socket(), server_hostname=hostname)
conn.connect((hostname, 443))

# Retrieve the certificate information
cert = conn.getpeercert()

# Print all the cipher suites supported by the website
print(context.get_ciphers())


# Check whether the certificate has the 'subjectAltName' field, which indicates SNI support
#This code will establish a secure connection to the website using the ssl module and retrieve the certificate information using the getpeercert() method. It will then check the subjectAltName field in the certificate to determine whether the website supports SNI. If the subjectAltName field is present, the website supports SNI. If it is not present, the website does not support SNI.
if 'subjectAltName' in cert:
    print('This website supports SNI.')
else:
    print('This website does not support SNI.')
    
# Check whether the certificate has the 'OCSP' field, which indicates OCSP support
#This code will establish a secure connection to the website using the ssl module and retrieve the certificate information using the getpeercert() method. It will then check the OCSP field in the certificate to determine whether the website supports OCSP. If the OCSP field is present, the website supports OCSP. If it is not present, the website does not support OCSP.
if 'OCSP' in cert:
    print('This website supports OCSP.')
else:
    print('This website does not support OCSP.')

#HSTS This code will send an HTTP request to the website using the requests module and check the Strict-Transport-Security header in the response. If the header is present, the website supports HSTS. If it is not present, the website does not support HSTS.
# Send an HTTP request to the website
response = requests.get(f'http://{hostname}')

# Check the 'Strict-Transport-Security' header in the response
if 'Strict-Transport-Security' in response.headers:
    print('This website supports HSTS.')
else:
    print('This website does not support HSTS.')
    
# Send a DNS query for the CAA record of the website
answers = dns.resolver.query(hostname, 'CAA')

# Print the CAA record(s)
for rdata in answers:
    print(rdata)
    
#This code will send a request to the website using the requests library and retrieve the response headers using the headers attribute of the Response object. It will then check if the 'Via' header is present in the headers, which indicates that WAN Optimization is being used. If the 'Via' header is present, the code will print a message indicating that the website is using WAN Optimization. If the 'Via' header is not present, the code will print a message indicating that the website is not using WAN Optimization.

#The code will also check if the 'X-Firefox-Spdy' header is present in the headers, which indicates that HTTP/2 is being used. If the 'X-Firefox-Spdy' header is present, the code will print a message indicating that the website is using HTTP/2. If the 'X-Firefox-Spdy' header is not present, the code will print a message indicating that the website is not using HTTP/2.

# Retrieve the response headers
headers = response.headers

# Check if the 'Via' header is present, which indicates that WAN Optimization is being used
if 'Via' in headers:
    print('The website is using WAN Optimization')
else:
    print('The website is not using WAN Optimization')

# Check if the 'X-Firefox-Spdy' header is present, which indicates that HTTP/2 is being used
if 'X-Firefox-Spdy' in headers:
    print('The website is using HTTP/2')
else:
    print('The website is not using HTTP/2')
    
#This code will establish a secure connection to the website using the ssl module and retrieve the cipher suite being used using the cipher() method of the SSLSocket object. It will then check if the cipher suite uses a fast cryptographic primitive by checking if the string 'CHACHA20' or 'GCM' is present in the cipher suite. If the cipher suite uses a fast cryptographic primitive, the code will print a message indicating the name of the cipher suite being used. If the cipher suite does not use a fast cryptographic primitive, the code will print a message indicating the name of the cipher suite being used.
    
# Retrieve the cipher suite being used
cipher = conn.cipher()[0]

# Check if the cipher suite uses a fast cryptographic primitive
if 'CHACHA20' in cipher or 'GCM' in cipher:
    print(f'The website is using a fast cryptographic primitive ({cipher})')
else:
    print(f'The website is not using a fast cryptographic primitive ({cipher})')

    
print("errors-errors-errors-errors-errors-errors-errors-errors-errors-errors-errors-errors-errors-errors-errors-errors-errors-errors-errors-errors-errors-errors-errors-errors-errors-")
#--------------------------------------------------------------------------------------------------------------------------------------------#

# Parse the HTML using BeautifulSoup
soup = BeautifulSoup(response.text, 'html.parser')

# Find all elements that are loading resources over an insecure connection
insecure_elements = soup.find_all(src=lambda src: src and src.startswith('http://'))

# Check if any insecure elements were found
if insecure_elements:
    print('The website has mixed content')
else:
    print('The website does not have mixed content')

# Retrieve the response headers
headers = response.headers

# Check if the 'Cache-Control' header is present and has a value of 'public', which indicates that the content is being cached
if 'Cache-Control' in headers and headers['Cache-Control'] == 'public':
    print('The website is caching public content')
else:
    print('The website is not caching public content')

# Establish the first secure connection to the website
context = ssl.create_default_context()
conn1 = context.wrap_socket(socket.socket(), server_hostname=hostname)
conn1.connect((hostname, 443))

# Retrieve the session id for the first connection
session_id1 = conn1.session.id

# Establish the second secure connection to the website
context = ssl.create_default_context()
conn2 = context.wrap_socket(socket.socket(), server_hostname=hostname)
conn2.connect((hostname, 443))

# Retrieve the session id for the second connection
session_id2 = conn2.session.id

# Check if the session id for the second connection is the same as the session id for the first connection, which indicates that Session Resumption is being used
if session_id1 == session_id2:
    print(f'The website is using Session Resumption with session id: {session_id1}')
else:
    print('The website is not using Session Resumption')

conn1.close()
conn2.close()


# Establish the first secure connection to the website
context = ssl.create_default_context()
conn1 = context.wrap_socket(socket.socket(), server_hostname=hostname)
conn1.connect((hostname, 443))

# Retrieve the session ticket for the first connection
session_ticket1 = conn1.get_session().ticket

# Establish the second secure connection to the website
context = ssl.create_default_context()
conn2 = context.wrap_socket(socket.socket(), server_hostname=hostname)
conn2.connect((hostname, 443))

# Retrieve the session ticket for the second connection
session_ticket2 = conn2.get_session().ticket

# Check if the session ticket for the second connection is not empty, which indicates that Session Resumption with tickets is being used
if session_ticket2:
    print(f'The website is using Session Resumption with tickets')
else:
    print('The website is not using Session Resumption with tickets')

conn1.close()
conn2.close()

# Retrieve the session id
session_id = conn.session.id

# Check if the session id is not empty, which indicates that Session Resumption is being used
if session_id:
    print(f'The website is using Session Resumption with session id: {session_id}')
else:
    print('The website is not using Session Resumption')



# Retrieve the cipher suite information
cipher, version, bits, alg = conn.cipher()

# Check if the cipher suite supports Forward Secrecy
if '_DHE_' in cipher or '_ECDHE_' in cipher:
    print(f'The cipher suite supports Forward Secrecy: {cipher}')
else:
    print(f'The cipher suite does not support Forward Secrecy: {cipher}')


# Extract the signature algorithm from the certificate
sig_alg = cert['signatureAlgorithm']['name']

# Define a list of strong signature algorithms
strong_sig_algs = ['sha256WithRSAEncryption', 'sha384WithRSAEncryption', 'sha512WithRSAEncryption', 'sha256WithRSAPSS', 'sha384WithRSAPSS', 'sha512WithRSAPSS']

# Check if the signature algorithm is strong
if sig_alg in strong_sig_algs:
    print(f'The signature algorithm is strong: {sig_alg}')
else:
    print(f'The signature algorithm is weak: {sig_alg}')

# Print the key length
print(f'Key length: {key_length} bits')

# Extract the key length from the certificate
key_length = cert['subjectKeyInfo']['keySize']

# Check if the key length is less than or equal to 2048 bits
if key_length <= 2048:
    print('The key length is less than or equal to 2048 bits.')
else:
    print('The key length is more than 2048 bits.')
    
# Extract the issuer name from the certificate
issuer_name = cert['issuer']['O']

# Check if the certificate was issued by a reliable CA
if issuer_name in ['Let\'s Encrypt', 'DigiCert Inc', 'GlobalSign', 'Comodo', 'Entrust, Inc.']:
    print(f'The certificate was issued by a reliable CA: {issuer_name}')
else:
    print(f'The certificate was issued by an unknown CA: {issuer_name}')

    
conn.close()